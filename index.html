<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>WLED PWA Test (errors visible)</title>

  <link rel="manifest" href="./manifest.webmanifest">
  <meta name="theme-color" content="#0b0b0f">
  <link rel="icon" href="./icon-192.png">

  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#0b0b0f; color:#eaeaf2; }
    .wrap { max-width: 720px; margin: 0 auto; padding: 18px 14px 40px; }
    h1 { margin: 10px 0 6px; font-size: 22px; }
    .sub { opacity:.7; font-size: 13px; line-height: 1.35; }
    .card { margin-top: 14px; background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.10); border-radius: 16px; padding: 14px; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items: center; }
    input { width: 100%; box-sizing: border-box; padding: 12px 12px; border-radius: 12px; border:1px solid rgba(255,255,255,.14); background: rgba(0,0,0,.35); color:#fff; font-size: 16px; }
    button { padding: 12px 12px; border-radius: 14px; border:1px solid rgba(255,255,255,.16); background: rgba(255,255,255,.08); color:#fff; font-size: 15px; cursor:pointer; }
    button:active { transform: translateY(1px); }
    .pill { display:inline-flex; padding: 8px 10px; border-radius: 999px; border:1px solid rgba(255,255,255,.14); background: rgba(0,0,0,.25); font-size: 13px; opacity:.9; }
    .ok { color: #8ff0a4; }
    .bad { color: #ff7b72; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 12px; white-space: pre-wrap; word-break: break-word; }
    .big { font-size: 16px; line-height:1.35; }
    .hint { opacity:.75; font-size: 12px; line-height: 1.35; margin-top: 10px; }
    .sep { height:1px; background: rgba(255,255,255,.10); margin: 12px 0; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 560px) { .grid2 { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>WLED PWA Test</h1>
    <div class="sub">
      Цель: чтобы на экране было видно, почему запросы к WLED не проходят.<br>
      Этот тест показывает: URL, попытку запроса, результат, и детальный текст ошибки.
    </div>

    <div class="card">
      <div class="row">
        <span class="pill">Origin: <span id="origin" class="mono" style="margin-left:6px"></span></span>
        <span class="pill">Protocol: <span id="proto" class="mono" style="margin-left:6px"></span></span>
        <span class="pill">SW: <span id="sw" class="mono" style="margin-left:6px"></span></span>
      </div>

      <div class="sep"></div>

      <div class="big">
        1) Введи IP WLED (пример: <span class="mono">10.183.228.118</span>)<br>
        2) Нажми <b>GET /json/info</b><br>
        3) Смотри блок <b>RESULT</b> - там будет точная ошибка
      </div>

      <div style="margin-top:10px">
        <label class="sub">WLED host (IP или имя без http://)</label>
        <input id="host" placeholder="10.183.228.118" value="10.183.228.118" />
      </div>

      <div class="grid2" style="margin-top:10px">
        <button id="btnInfo">GET /json/info</button>
        <button id="btnState">POST /json/state (toggle on/off)</button>
      </div>

      <div class="hint">
        Важно: если Origin = https://… (GitHub Pages), а WLED = http://…, браузер часто блокирует это как mixed content.
        Тогда в RESULT ты увидишь ошибку типа <span class="mono">TypeError: Failed to fetch</span> и диагноз ниже.
      </div>
    </div>

    <div class="card">
      <div class="row">
        <span class="pill">RESULT: <span id="resBadge" class="mono" style="margin-left:6px">idle</span></span>
        <span class="pill">Last URL: <span id="lastUrl" class="mono" style="margin-left:6px">-</span></span>
      </div>

      <div class="sep"></div>

      <div class="sub">Human diagnosis</div>
      <div id="diagnosis" class="big" style="margin-top:6px; opacity:.95">-</div>

      <div class="sep"></div>

      <div class="sub">Raw details</div>
      <div id="raw" class="mono" style="margin-top:6px">-</div>
    </div>

    <div class="card">
      <div class="big"><b>Проверка кэша (без отключения интернета)</b></div>
      <div class="sub" style="margin-top:6px">
        Нажми кнопку - она попросит Service Worker отдать файл из кэша (если кэширование включено и файл уже был закэширован).
        Это тест логики, а не “настоящий оффлайн”.
      </div>
      <div class="grid2" style="margin-top:10px">
        <button id="btnCacheSelf">Cache-test: fetch ./cache-test.txt</button>
        <button id="btnForceUpdate">Force update SW + reload</button>
      </div>
      <div class="sep"></div>
      <div class="sub">Cache-test output</div>
      <div id="cacheOut" class="mono" style="margin-top:6px">-</div>
    </div>
  </div>

<script>
  const el = (id) => document.getElementById(id);

  function setBadge(text, ok=null) {
    el("resBadge").textContent = text;
    el("resBadge").className = "mono " + (ok === true ? "ok" : ok === false ? "bad" : "");
  }

  function setRaw(obj) {
    el("raw").textContent = typeof obj === "string" ? obj : JSON.stringify(obj, null, 2);
  }

  function setDiag(text, ok=null) {
    el("diagnosis").textContent = text;
    el("diagnosis").className = "big " + (ok === true ? "ok" : ok === false ? "bad" : "");
  }

  function hostToBase(host) {
    host = (host || "").trim();
    host = host.replace(/^https?:\/\//i, "");
    host = host.replace(/\/+$/,"");
    return "http://" + host; // WLED обычно http. Это важно для диагностики.
  }

  function looksLikeMixedContent() {
    // Если origin https, а цель http - это типовая причина.
    return location.protocol === "https:";
  }

  function mixedContentDiagnosis(url) {
    if (!looksLikeMixedContent()) return null;
    if (url.startsWith("http://")) {
      return "Похоже на блокировку mixed content: страница открыта по HTTPS, а запрос идёт на HTTP (локальный IP). Браузер может блокировать такие fetch-запросы. Это объясняет, почему Termux (curl) работает, а PWA нет.";
    }
    return null;
  }

  async function doFetch(url, opts) {
    el("lastUrl").textContent = url;
    setBadge("requesting…", null);
    setDiag("Запрос отправлен, ждём ответ…", null);
    setRaw({ url, opts });

    const t0 = Date.now();
    try {
      const res = await fetch(url, opts);

      const dt = Date.now() - t0;
      const ct = res.headers.get("content-type") || "";
      const text = await res.text();

      setBadge(`HTTP ${res.status} (${dt}ms)`, res.ok);
      let diag = res.ok ? "Ответ получен. Если UI не менялся раньше - значит проблема была в блокировке/ошибке запроса." : "Сервер ответил, но статус не OK. Смотри Raw details.";
      setDiag(diag, res.ok);

      // Пытаемся красиво показать JSON, если это JSON
      if (ct.includes("application/json") || text.trim().startsWith("{") || text.trim().startsWith("[")) {
        try {
          const j = JSON.parse(text);
          setRaw({ status: res.status, ok: res.ok, headers: Object.fromEntries(res.headers.entries()), json: j });
        } catch {
          setRaw({ status: res.status, ok: res.ok, headers: Object.fromEntries(res.headers.entries()), body: text.slice(0, 4000) });
        }
      } else {
        setRaw({ status: res.status, ok: res.ok, headers: Object.fromEntries(res.headers.entries()), body: text.slice(0, 4000) });
      }
      return;
    } catch (err) {
      const dt = Date.now() - t0;
      setBadge(`ERROR (${dt}ms)`, false);

      // Главная польза: показываем человеку, что именно сказал браузер.
      const raw = {
        name: err?.name,
        message: err?.message,
        stack: err?.stack,
        hint: "Если это TypeError: Failed to fetch - причин несколько, но для HTTPS-PWA -> HTTP-IP самая частая: mixed content."
      };
      setRaw(raw);

      const mc = mixedContentDiagnosis(url);
      if (mc) {
        setDiag(mc, false);
      } else {
        setDiag("Fetch упал. Смотри Raw details (name/message).", false);
      }
    }
  }

  let toggle = false;

  el("btnInfo").addEventListener("click", async () => {
    const base = hostToBase(el("host").value);
    await doFetch(base + "/json/info", { method: "GET", cache: "no-store" });
  });

  el("btnState").addEventListener("click", async () => {
    const base = hostToBase(el("host").value);
    toggle = !toggle;
    const body = JSON.stringify({ on: toggle });
    await doFetch(base + "/json/state", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body,
      cache: "no-store"
    });
  });

  // Cache-test file
  el("btnCacheSelf").addEventListener("click", async () => {
    try {
      const res = await fetch("./cache-test.txt", { cache: "default" });
      const text = await res.text();
      el("cacheOut").textContent = `status=${res.status} ok=${res.ok}\n` + text;
    } catch (e) {
      el("cacheOut").textContent = `ERROR: ${e?.name} ${e?.message}`;
    }
  });

  el("btnForceUpdate").addEventListener("click", async () => {
    try {
      if ("serviceWorker" in navigator) {
        const reg = await navigator.serviceWorker.getRegistration();
        if (reg) {
          await reg.update();
        }
      }
      location.reload();
    } catch (e) {
      alert(`Force update error: ${e?.name} ${e?.message}`);
    }
  });

  // top status pills
  el("origin").textContent = location.origin;
  el("proto").textContent = location.protocol;

  (async () => {
    if (!("serviceWorker" in navigator)) {
      el("sw").textContent = "unsupported";
      return;
    }
    try {
      const reg = await navigator.serviceWorker.register("./sw.js", { scope: "./" });
      const state = reg.active ? "active" : (reg.installing ? "installing" : "registered");
      el("sw").textContent = state;
    } catch (e) {
      el("sw").textContent = "register failed";
      // Покажем это тоже
      setBadge("SW register ERROR", false);
      setDiag("Service Worker не зарегистрировался. Смотри Raw details.", false);
      setRaw({ swRegisterError: { name: e?.name, message: e?.message, stack: e?.stack } });
    }
  })();
</script>
</body>
</html>